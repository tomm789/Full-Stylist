"use strict";

// Handler for rendering an outfit on the user's body.
// Now supports client-side stacked images via stacked_image_id input.
// When stacked_image_id is provided, we download only 3 images total:
// body + head + stacked_items, which fits well under all model limits.

const sharp = require('sharp');
const { PROMPTS } = require("../prompts");
const {
  downloadImageFromStorage,
  uploadImageToStorage,
  callGeminiAPI,
  optimizeGeminiOutput
} = require("../utils");

/**
 * Renders an outfit on the user's body shot. Supports two input modes:
 * 1. stacked_image_id: Pre-stacked wardrobe items (recommended, faster)
 * 2. selected: Array of wardrobe items to fetch individually (legacy)
 *
 * @param {object} input - Job input including outfit_id, stacked_image_id or selected items
 * @param {import('@supabase/supabase-js').SupabaseClient} supabase - Supabase client
 * @param {string} userId - The ID of the user
 * @param {object} perfTracker - Optional performance tracker for timing measurements
 * @param {object} timingTracker - Optional timing tracker for detailed step-by-step timing
 * @returns {Promise<{renders: Array<{image_id: number, storage_key: string}>}>} Render results
 */
async function processOutfitRender(input, supabase, userId, perfTracker = null, timingTracker = null) {
  const {
    outfit_id,
    stacked_image_id,
    selected,
    prompt,
    settings,
    headshot_image_id
  } = input;

  if (!outfit_id) {
    throw new Error("Missing outfit_id");
  }

  // Require either stacked_image_id OR selected items
  if (!stacked_image_id && (!selected || selected.length === 0)) {
    throw new Error("Missing stacked_image_id or selected items");
  }

  const useStackedImage = !!stacked_image_id;
  console.log(`[OutfitRender] Processing outfit ${outfit_id}, using ${useStackedImage ? 'pre-stacked' : 'individual'} images`);

  // Retrieve user settings for default head/body shots, model preference, and headshot inclusion setting
  const { data: userSettings } = await supabase
    .from("user_settings")
    .select("headshot_image_id, body_shot_image_id, ai_model_preference, include_headshot_in_generation")
    .eq("user_id", userId)
    .single();

  const bodyId = userSettings?.body_shot_image_id;
  const includeHeadshot = userSettings?.include_headshot_in_generation ?? false;
  const headId = includeHeadshot ? (headshot_image_id || userSettings?.headshot_image_id) : null;

  if (!bodyId) {
    throw new Error("Missing body shot");
  }

  // Only require headshot if the setting is enabled
  if (includeHeadshot && !headId) {
    throw new Error("Missing headshot (required when include_headshot_in_generation is enabled)");
  }

  const preferredModel = userSettings?.ai_model_preference || "gemini-2.5-flash-image";

  let stackedItemsB64;
  let itemCount;

  if (useStackedImage) {
    // Client-side stacked image - download from storage using the path!
    console.log(`[OutfitRender] Downloading pre-stacked image from storage: ${stacked_image_id}`);
    
    try {
      // stacked_image_id is actually a storage path like "user-id/ai/stacked/stacked-123.jpg"
      const { data: stackedBlob, error: downloadError } = await supabase
        .storage
        .from('media')
        .download(stacked_image_id);
      
      if (downloadError) {
        console.error(`[OutfitRender] Storage download error:`, downloadError);
        throw new Error(`Failed to download stacked image: ${downloadError.message}`);
      }
      
      if (!stackedBlob) {
        throw new Error('Downloaded blob is null or undefined');
      }
      
      console.log(`[OutfitRender] Downloaded blob size: ${stackedBlob.size} bytes, type: ${stackedBlob.type}`);
      
      // Convert blob to base64
      const buffer = await stackedBlob.arrayBuffer();
      console.log(`[OutfitRender] Converted to ArrayBuffer, length: ${buffer.byteLength}`);
      
      stackedItemsB64 = Buffer.from(buffer).toString('base64');
      console.log(`[OutfitRender] Converted to base64, length: ${stackedItemsB64.length} chars`);
      
      itemCount = settings?.items_count || selected?.length || 0;
      console.log(`[OutfitRender] Pre-stacked image contains ${itemCount} items`);
    } catch (error) {
      console.error(`[OutfitRender] Error processing stacked image:`, error);
      throw new Error(`Failed to process stacked image: ${error.message}`);
    }
  } else {
    // Legacy mode: fetch individual items (this shouldn't happen with client-side stacking)
    console.log(`[OutfitRender] Legacy mode: fetching ${selected.length} individual items`);
    
    const wardrobeItemIds = selected.map((s) => s.wardrobe_item_id);
    const { data: allLinks } = await supabase
      .from("wardrobe_item_images")
      .select("wardrobe_item_id, type, sort_order, image_id")
      .in("wardrobe_item_id", wardrobeItemIds);

    const linksByItem = new Map();
    (allLinks || []).forEach((link) => {
      if (!linksByItem.has(link.wardrobe_item_id)) {
        linksByItem.set(link.wardrobe_item_id, []);
      }
      linksByItem.get(link.wardrobe_item_id).push(link);
    });

    const imageIdsToDownload = [];
    wardrobeItemIds.forEach((itemId) => {
      const links = linksByItem.get(itemId);
      if (!links?.length) return;

      links.sort((a, b) => {
        if (a.type === "product_shot" && b.type !== "product_shot") return -1;
        if (b.type === "product_shot" && a.type !== "product_shot") return 1;
        return (a.sort_order || 999) - (b.sort_order || 999);
      });

      if (links[0]?.image_id) {
        imageIdsToDownload.push(links[0].image_id);
      }
    });

    if (!imageIdsToDownload.length) {
      throw new Error("No valid images found for outfit items");
    }

    // For legacy mode with multiple items, download ALL images
    // Gemini can handle multiple images in a single request
    console.log(`[OutfitRender] Legacy mode: downloading ${imageIdsToDownload.length} images: ${imageIdsToDownload.join(', ')}`);
    const itemImageResults = await Promise.all(
      imageIdsToDownload.map(id => {
        console.log(`[OutfitRender] Downloading item image: ${id}`);
        return downloadImageFromStorage(supabase, id, timingTracker);
      })
    );
    
    console.log(`[OutfitRender] Downloaded ${itemImageResults.length} item images`);
    
    // Extract base64 from results
    const itemImagesB64 = itemImageResults.map(result => result.base64);
    
    // In legacy mode, we'll return the first one as the "stackedItemsB64" 
    // but we'll actually use all of them in the Gemini call
    stackedItemsB64 = itemImagesB64; 
    itemCount = imageIdsToDownload.length;
  }

  // Download body (always required) and headshot (conditionally)
  console.log(`[OutfitRender] Downloading body image${includeHeadshot ? ' and headshot' : ''}`);
  const downloadPromises = [downloadImageFromStorage(supabase, bodyId, timingTracker)];
  if (includeHeadshot && headId) {
    downloadPromises.push(downloadImageFromStorage(supabase, headId, timingTracker));
  }
  
  const downloadedImageResults = await Promise.all(downloadPromises);
  const bodyResult = downloadedImageResults[0];
  const headResult = includeHeadshot && downloadedImageResults[1] ? downloadedImageResults[1] : null;

  if (includeHeadshot && headResult) {
    console.log(`[OutfitRender] Downloaded head (${headResult.base64.length} chars) and body (${bodyResult.base64.length} chars)`);
  } else {
    console.log(`[OutfitRender] Downloaded body (${bodyResult.base64.length} chars), headshot excluded`);
  }
  
  // Prepare all inputs for Gemini - conditionally include headshot
  // Pass full result objects to include mime-types
  let allInputs = [bodyResult];
  if (includeHeadshot && headResult) {
    allInputs.push(headResult);
  }
  // stackedItemsB64 might be a string (pre-stacked) or array of strings
  // Convert to objects with default mime-type for backward compatibility
  if (Array.isArray(stackedItemsB64)) {
    const stackedInputs = stackedItemsB64.map(b64 => 
      typeof b64 === 'string' ? { base64: b64, mimeType: 'image/jpeg' } : b64
    );
    allInputs = [...allInputs, ...stackedInputs];
  } else {
    const stackedInput = typeof stackedItemsB64 === 'string' 
      ? { base64: stackedItemsB64, mimeType: 'image/jpeg' }
      : stackedItemsB64;
    allInputs.push(stackedInput);
  }

  console.log(`[OutfitRender] Total images being sent to AI: ${allInputs.length}`);

  // Verify all images are valid base64
  const isValidBase64 = (str) => {
    try {
      return btoa(atob(str)) === str;
    } catch (e) {
      return false;
    }
  };

  allInputs.forEach((img, i) => {
    console.log(`[OutfitRender] Image ${i} valid base64: ${isValidBase64(img)}`);
  });

  // Now we have all images: body, head, and all outfit items
  console.log(`[OutfitRender] Generating outfit with model: ${preferredModel}`);

  // Debug: Check image dimensions before sending to Gemini API
  try {
    // Decode base64 and get metadata for body image
    const bodyBuffer = Buffer.from(bodyB64, 'base64');
    const bodyMetadata = await sharp(bodyBuffer).metadata();
    
    // Decode base64 and get metadata for head image (if included)
    let headMetadata = null;
    if (includeHeadshot && headB64) {
      const headBuffer = Buffer.from(headB64, 'base64');
      headMetadata = await sharp(headBuffer).metadata();
    }
    
    // Handle stackedItemsB64 (can be string or array)
    let stackedItemsDimensions = '';
    if (Array.isArray(stackedItemsB64)) {
      // Multiple images in legacy mode - show first one for main log
      if (stackedItemsB64.length > 0) {
        const firstItemBuffer = Buffer.from(stackedItemsB64[0], 'base64');
        const firstItemMetadata = await sharp(firstItemBuffer).metadata();
        stackedItemsDimensions = `${firstItemMetadata.width}x${firstItemMetadata.height}`;
        const headInfo = headMetadata ? `Head: ${headMetadata.width}x${headMetadata.height}, ` : '';
        console.log(`[Debug] Body: ${bodyMetadata.width}x${bodyMetadata.height}, ${headInfo}StackedItems[0]: ${stackedItemsDimensions}`);
        // Log additional items if any
        for (let i = 1; i < stackedItemsB64.length; i++) {
          const itemBuffer = Buffer.from(stackedItemsB64[i], 'base64');
          const itemMetadata = await sharp(itemBuffer).metadata();
          console.log(`[Debug] StackedItems[${i}]: ${itemMetadata.width}x${itemMetadata.height}`);
        }
      }
    } else {
      // Single stacked image
      const stackedBuffer = Buffer.from(stackedItemsB64, 'base64');
      const stackedMetadata = await sharp(stackedBuffer).metadata();
      stackedItemsDimensions = `${stackedMetadata.width}x${stackedMetadata.height}`;
      const headInfo = headMetadata ? `Head: ${headMetadata.width}x${headMetadata.height}, ` : '';
      console.log(`[Debug] Body: ${bodyMetadata.width}x${bodyMetadata.height}, ${headInfo}StackedItems: ${stackedItemsDimensions}`);
    }
  } catch (debugError) {
    console.error(`[Debug] Error checking image dimensions:`, debugError);
    // Don't throw - continue with the render even if debug fails
  }

  // Use the appropriate prompt with headshot inclusion setting
  const finalPrompt = useStackedImage 
    ? PROMPTS.OUTFIT_FINAL_STACKED(prompt || "No additional details", itemCount, includeHeadshot)
    : PROMPTS.OUTFIT_FINAL(prompt || "No additional details", itemCount, includeHeadshot);

  console.log(`[OutfitRender] Calling Gemini API...`);
  
  const finalImageB64 = await callGeminiAPI(
    finalPrompt,
    allInputs,
    preferredModel,
    "IMAGE",
    perfTracker,
    timingTracker
  );

  console.log(`[OutfitRender] AI generation complete, result length: ${finalImageB64.length} chars`);

  // Optimize the generated image before upload
  console.log(`[OutfitRender] Optimizing generated image...`);
  const optimizedImageB64 = await optimizeGeminiOutput(finalImageB64);
  console.log(`[OutfitRender] Image optimization complete`);

  // Upload the optimized final composite
  const timestamp = Date.now();
  const storagePath = `${userId}/ai/outfits/${outfit_id}/${timestamp}.jpg`;
  const { imageId, storageKey } = await uploadImageToStorage(
    supabase,
    userId,
    optimizedImageB64,
    storagePath
  );

  console.log(`[OutfitRender] Uploaded final image: ${storageKey}`);

  // Record the render and update the outfit cover image
  await supabase.from("outfit_renders").insert({
    outfit_id,
    image_id: imageId,
    prompt: prompt || null,
    settings: { 
      ...(settings || {}), 
      items_count: itemCount,
      used_stacked_image: useStackedImage
    },
    status: "succeeded"
  });

  await supabase
    .from("outfits")
    .update({ cover_image_id: imageId })
    .eq("id", outfit_id);

  console.log(`[OutfitRender] Outfit render complete`);

  return { 
    renders: [{ image_id: imageId, storage_key: storageKey }],
    items_count: itemCount,
    used_stacked_image: useStackedImage
  };
}

module.exports = { processOutfitRender };
