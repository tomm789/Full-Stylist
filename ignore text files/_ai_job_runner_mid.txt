  console.log(`[BatchJob] Starting batch processing for imageId: ${imageId}, tasks: ${tasks.join(', ')}`);
  
  // Download the image once to a buffer (returns { base64, mimeType } object)
  console.log(`[BatchJob] Downloading image once for shared use...`);
  const imageData = await downloadImageFromStorage(supabase, imageId, timingTracker);
  console.log(`[BatchJob] Image downloaded successfully, length: ${imageData.base64.length}, mimeType: ${imageData.mimeType}`);
  
  // Prepare inputs for both tasks
  const productShotInput = tasks.includes('product_shot') ? {
    image_id: imageId,
    wardrobe_item_id
  } : null;
  
  const autoTagInput = tasks.includes('auto_tag') ? {
    wardrobe_item_id,
    image_ids: image_ids || []
  } : null;
  
  // Validate auto_tag input if needed
  if (tasks.includes('auto_tag')) {
    if (!image_ids || !Array.isArray(image_ids) || image_ids.length === 0) {
      throw new Error("auto_tag task requires image_ids array");
    }
  }
  
  // CRITICAL: Create both promises in the SAME synchronous block - no awaits between them
  // This ensures both async functions start executing immediately and run in parallel
  const batchStart = performance.now();
  console.log(`[BatchJob] Creating both promises simultaneously (parallel execution starts now)...`);
  
  // Create promise array and start BOTH tasks immediately without any await
  const taskPromises = [];
  
  // Create product_shot promise - function starts executing immediately (no await)
  if (productShotInput) {
    console.log(`[BatchJob] Creating product_shot promise (execution starts immediately)...`);
    const productShotPromise = processProductShot(
      productShotInput,
      supabase,
      userId,
      perfTracker,
      timingTracker,
      imageData,
      jobId
    ).then(result => {
      const elapsed = ((performance.now() - batchStart) / 1000).toFixed(2);
      console.log(`[BatchJob] product_shot completed in ${elapsed}s`);
      return { task: 'product_shot', result, error: null };
    }).catch(err => {
      const elapsed = ((performance.now() - batchStart) / 1000).toFixed(2);
      console.error(`[BatchJob] product_shot failed after ${elapsed}s:`, err.message);
      return { task: 'product_shot', result: null, error: err.message };
    });
    taskPromises.push(productShotPromise);
  }
  
  // Create auto_tag promise IMMEDIATELY after (no await) - both run in parallel
  if (autoTagInput) {
    console.log(`[BatchJob] Creating auto_tag promise (execution starts immediately, parallel with product_shot)...`);
    const autoTagPromise = processAutoTag(
      autoTagInput,
      supabase,
      perfTracker,
      timingTracker,
      imageData,
      jobId
    ).then(result => {
      const elapsed = ((performance.now() - batchStart) / 1000).toFixed(2);
      console.log(`[BatchJob] auto_tag completed in ${elapsed}s`);
      return { task: 'auto_tag', result, error: null };
    }).catch(err => {
      const elapsed = ((performance.now() - batchStart) / 1000).toFixed(2);
      console.error(`[BatchJob] auto_tag failed after ${elapsed}s:`, err.message);
      return { task: 'auto_tag', result: null, error: err.message };
    });
    taskPromises.push(autoTagPromise);
  }
  
  // Both promises are now created and executing in parallel
  // Only NOW do we await - Promise.all waits for BOTH to complete
  console.log(`[BatchJob] Both promises created. Awaiting ${taskPromises.length} promises with Promise.all() (both running in parallel)...`);
  const results = await Promise.all(taskPromises);
  
  // Capture end time after Promise.all() completes
  const batchEnd = performance.now();
  const batchDuration = ((batchEnd - batchStart) / 1000).toFixed(2);
  
  // Track the parallel execution time
  if (timingTracker && typeof timingTracker.setBatchAIGenerationTime === 'function') {
    timingTracker.setBatchAIGenerationTime(parseFloat(batchDuration) * 1000); // Convert to ms
  }
  
  console.log(`[BatchJob] All tasks completed in ${batchDuration}s (parallel execution - should be ~max of individual task times, not sum)`);
  
  // Organize results by task name
  const taskResults = {};
  for (const { task, result, error } of results) {
    if (error) {
      taskResults[task] = { error };
      console.error(`[BatchJob] Task ${task} failed:`, error);
    } else {
      taskResults[task] = result;
      console.log(`[BatchJob] Task ${task} completed successfully`);
    }
  }
  
  console.log(`[BatchJob] All tasks completed`);
  return taskResults;
}